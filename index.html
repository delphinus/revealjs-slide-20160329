<!doctype html>
<html>

  <head>
    <meta charset="utf-8">

    <title>TypeScript による今風の Web アプリ開発</title>

    <meta name="description" content="slide for 2016-03-29 MTG">
    <meta name="author" content="delphinus">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css" id="theme">
    <link rel="stylesheet" href="lib/font/source-sans-pro/source-sans-pro.css">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->

    <style>
      @font-face {
        font-family: Lato;
        src: local(SourceSansPro);
      }
      @font-face {
        font-family: sans-serif;
        src: local(HiraginoSans-W1);
      }
      @font-face {
        font-family: monospace;
        src: local(Ricty);
      }
    </style>
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-markdown>
          <script type="text/template">
            # TypeScript による<br>今風の<br>Web アプリ開発
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## TypeScript とは……
            * 次世代 JS - ECMAScript2015 の上位互換 + 型
            * Microsoft 製
            * オープンソース
            * 各種エディタのサポートが充実
              - MS 製だけど Visual Studio は別に必要ない。
              - IntelliSense 並みのコード補完を実現するための仕組みが附属。
                - Vim でも補完できる！
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## ECMAScript2015 で<br>追加された文法
            * Class & Module
            * Arrow Function `() => {}`
            * Block Scope Variables `let, const`
            * Rest / Spread Parameters `(a, b, ...args) => {}`
            * New Object Literals `{some, more, props}`
            * Map / Set, Promise, Generator, Symbol, ...
            * 今後まだまだ増える予定（ES2017 以降?）
              - Decorator, async / await, ...
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## module loading
            * `some_module.js`
              ```typescript
              export const hoge = "ほげ";
              export function fuga { console.log("ふが"); };
              ```
            * `app.js`
              ```typescript
              import {hoge, fuga} from "./some_module";

              console.log(hoge);
              fuga();
              ```
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            * 今までの JS はモジュールという概念がなかった。
            * 変数のスコープは関数スコープのみ。
              - `function(){ var hoge; }`
            * 複数のファイルで変数・関数を共有したいと思ったらグローバル汚染するしかなかった。
              - ブラウザーなら `window.hoge = "ほげ"`
            * グローバル汚染せずに複数ファイルに分けて開発が可能になった！
              - 他の言語なら当たり前の機能がやっと……！
          </script>
        </section>:
        <section data-markdown>
          <script type="text/template">
            ## TypeScript は ES2015 + 型
            ```typescript
            let hoge: string = "ほげ";

            // hoge = 1; # => 型が string でないのでエラー！

            // オリジナルの型を定義できる
            type LogLevel = "debug" | "info" | "warn" | "error" | "fatal";

            function log(level: LogLevel, message: string) {
              console.log(`[${level}] ${message}`);
            }

            // log("waaarn", "fugafuga");
            // # => 第1引数の型が LogLevel と合致しないのでエラー！
            ```
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            * コンパイル時にエラーを見つけてくれる。
            * とかくフリーダムになりがちな JavaScript では凄く助かる。
            * 今回のプロジェクトではテストとかないのに、コンパイル通ったら一発で動いた！スゴイ！  
              <small>テストは書くべきだけどね……（結局書いてない）</small>
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            # 実践
            * TypeScript を Rails プロジェクトで使ってみた。
            * その中で遭遇した諸々。
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## 既存ライブラリーは<br>npm で管理
            * jQuery とか underscore.js とかいろいろ使いたいときもある。
            * 大体のライブラリーは [npm][] に登録してあるし、してないものは github から直で入れる。

              ```sh
              # jQuery のインストール
              npm install --save-dev --save-exact jquery
              ```

            * bower? 何それ (^q^)

            [npm]: https://www.npmjs.com
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## ツールはグローバルにインストールしない
            * 今までは gulp や typescript 等の関連ツールをグローバルにインストールして使ってた。
              ```sh
              npm install -g typescript
              # /usr/local/bin/typescript に入る
              ```
            * これだと各人が入れたバージョンを管理できない＞＜
            * ビルドした結果が違うと開発に齟齬を来す。
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## 各種ツールは npm 経由で実行
            * ツールのインストール先はプロジェクトローカル。
              ```sh
              npm install -DE gulp
              # node_modules/.bin/gulp に入る
              ```
            * gulp や browserify 等のツールも全部 npm 経由で実行する。
            * `package.json` にタスクを書いて、`npm run` で実行。
              ```sh
              npm start         # gulp 起動
              npm run build     # TS をコンパイル & browserify
              npm run clean     # ビルド済みのファイルを削除
              npm run tslint    # TS の文法チェック
              npm run typedoc   # ドキュメント作成
              ...
              ```
            * こうすると、必ずプロジェクトにローカルなバージョンに固定されるので開発者も戸惑わない。
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## パッケージの<br>バージョン管理
            * 各人の環境で、jQuery その他のライブラリや、TypeScript や gulp 等のツール類もバージョンを揃える必要がある。
            * `package.json` と `npm-shrinkwrap.json` で可能。
              - Ruby で言うなら `Gemfile.lock` みたいなもの。
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## 再び TypeScript の話
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## 既存の JS ライブラリと<br>共存する
            * 最初から TypeScript で書いてあるライブラリなんてほとんどない。
            * jQuery プラグインとか使いたい！
            * それ、型定義ファイルでできるよ。
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## 型定義ファイル
            * 既存のライブラリーが export する関数・変数などについての型情報が書いてある。
            * メジャーなライブラリーについては [DefinitelyTyped][] に揃ってる。
            * メジャーじゃないものは……自分で書くしかない。

            [DefinitelyTyped]: https://github.com/DefinitelyTyped/DefinitelyTyped
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            * 書いてみた例
              - [jquery-easy-loading.d.ts][jts]
            * 使用例
              ![使用例](img/loading-example.png)

            [jts]: https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/jquery-easy-loading/jquery-easy-loading.d.ts
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## 書いてみた結果……
            * 型定義ファイルを書くためにはライブラリーのソースを読んで理解しないといけない。
              - ドキュメントに返値の型までちゃんと書いてあれば楽なんだけどね……
            * 結構大変だけど書かないと開発始められない。  
              <small>全部 any 型にキャストすれば何とかならんでもない。</small>
            * 既存のライブラリーを使いたいときはこのコストとのトレードオフ。
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## 複数ファイルをまとめる
            * （TypeScript でも）複数ファイルでアプリを構成することはできるが、`<script>` をたくさん書くとパフォーマンス的にアレ。
            * 複数のモジュールを一つにまとめ、場合によっては難読化する。
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## browserify
            ```sh
            browserify myapp.js > bundle.js
            ```

            ### before

            ```html
            <script src="http://example.com/jquery.min.js">
            <script src="http://example.com/underscore.min.js">
            <script src="http://example.com/backbone.min.js">
            <script src="http://example.com/bootstrap.min.js">
            <script src="http://example.com/myapp.js">
            ```

            ### after

            ```html
            <script src="http://example.com/bundle.js">
            ```

            * ファイルサイズは相当でかくなるけどね。
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## Rails のアセットパイプライン
            * アセットパイプラインとは……
              - [アセットパイプライン | Rails日本語ドキュメント | Ruby STUDIO][as]
              - 簡単に言うと、複数の JS, CSS を連結・圧縮してくれる便利機能。Coffee や Sass からの透過的な変換もやってくれる。
              - スーパー便利すぎるが故に闇が深い＞＜
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## アセットパイプラインと共存する
            * Sprockets（アセット（略）の主要 gem）を全部 JavaScript で置き換えてしまった[スゴイ人も居る][sugoi]が、ここまでやるのは大変。
            * 折衷案として、browserify でビルドした一つの JS を `public/assets` に置く。
              - `app/assets/javascripts` は無視
            * パッケージによっては個別の CSS / img が必要なこともある。（bootstrap とか）
              - これらは `app/assets/...` に手でコピーしてアセットパイプラインに載せる。

            [as]: http://ruby.studio-kingdom.com/rails/guides/asset_pipeline
            [sugoi]: http://waka.github.io/2015/11/25/gulp_sprockets.html
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## タスクの自動化
            * 定型タスクを自動化する。
              - TypeScript をコンパイル。
              - 複数ファイルをビルドしてまとめる。
              - （必要なら）難読化する。
              - （必要なら）スクリプトを所定の場所に移動する。
              - などなど……
            * gulp がデファクトスタンダード。
              - Grunt? 何それ (^q^)
                - JS 界はこんなんばっかり……
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## gulp
            * 定型タスクの例
              ```javascript
              // JS の文法チェックを eslint で行う
              gulp.task(
                'eslint',
                () => gulp.src('gulp/**/*.js')
                  .pipe(plumber({errorHandler: handleErrors}))
                  .pipe(eslint())
                  .pipe(eslint.failOnError())
                  .pipe(plumber.stop())
              );
              ```
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            * だいぶ秘伝のタレ化してしまった。
            * プロジェクト固有のバッドノウハウの固まりなので一般化できない。メンテもしにくい。
            * せめて ES2015 で書いて eslint かけることで品質を担保。
            * gulp 自体バージョン変わると文法もごりごり変わるし、プロダクト自体すぐにオワコン化する。（Grunt ェ……）
              - この辺はホント JS キツイ。
              - 根本的な解決策は今のところない。
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## フロントエンドの<br>ログを取りたい！
            * 普通の Web アプリなら `console.log()` で十分。
            * でも WebView で表示してるときのログは見れない。
            * 本番環境ではユーザーの端末で致命的なエラーが起こったときに教えて欲しい。
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## ログをバックエンドに送るモジュールを書く
            ```typescript
            Logger.fatal = (message: string): JQueryPromise<{}> => {
              const level = "fatal";
              return $.post("/log", {level, message});
            };

            // 他にも Logger.info とか Logger.debug とか……
            ```
            * でもこれだと、どこでログを吐いたのか分からない。  
              (´・ω・｀)
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            ## Stacktrace-js
            * https://github.com/stacktracejs/stacktrace.js
            * スタックトレースが取れるスゴイやつ。

              ```typescript
              Logger.fatal = (message: string): Promise<{}> => {
                const level = "fatal";
                return StackTrace.get()
                  .then((stackframes: StackTrace.StackFrame[]) =>
                    Promise.resolve(
                      $.post("/log", {level, message, stackframes})
                    )
                  );
              };

              // 致命的エラーが起きたときだけサーバーに送信
              window.onerror = (message: string) => Logger.fatal(message);
              ```
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            # まとめ
            * JS 界隈は常に勉強して（≒空気を読んで）行かないとすぐにおいて行かれる。 <!-- .element: class="fragment" -->
            * Rails のような頼れる存在はいないので自分で道を切り開く必要がある。 <!-- .element: class="fragment" -->
            * メリット <!-- .element: class="fragment" -->
              - スゴイ勉強になる（意識高い感） <!-- .element: class="fragment" -->
              - 何もないからこそ、自分の思い通りに作れる万能感。 <!-- .element: class="fragment" -->
            * デメリット <!-- .element: class="fragment" -->
              - 各プロダクトがすぐオワコン化する。 <!-- .element: class="fragment" -->
              - 書いたソースがすぐ暗黒化する。 <!-- .element: class="fragment" -->
              - 一年後の自分ですらメンテできない。 <!-- .element: class="fragment" -->
            * ドキュメント大事！！！ <!-- .element: class="fragment" -->
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
            # 終わり
            [初めに戻る](#/)
          </script>
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });
      Reveal.configure({slideNumber: 'c/t'});

    </script>

  </body>
</html>
